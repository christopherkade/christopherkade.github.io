{"pageProps":{"frontmatter":{"title":"Introduction to Front-End unit testing","description":"A good start to your testing journey.","date":"2019-04-01","slug":"/posts/intro-to-testing","isPublished":true},"content":"\nAlright, you've dabbled with web developments, made a few projects here and there, deployed a few applications that helped you grasp essential concepts of Front-End development, from routing, server-side rendering, state-management to asynchronous queries etc.\n\nBut there's one thing you haven't put to practice, either because you were willingly avoiding it, or simply because you didn't see its use: testing. More specifically, Front-End unit testing, one _very important_ part of the testing ecosystem.\n\n## Unit testing? üßê\n\nI'll just go over the basic knowledge to understand the role of unit testing in your everyday applications.  \nEssentially, testing Front-End code can be divided into **3 categories**:\n\n![](https://user-images.githubusercontent.com/15229355/55113335-24fcff00-50df-11e9-87e8-cdd5e0e6ad3f.png)\n\n**E2E Testing** or end-to-end testing, is the practice of testing if the execution of an application is performing as designed from start to finish. The entire application is tested in real-world scenarios, which includes testing the communication between components such as the database, network, APIs etc. and executing your code in a diversity of browsers. Basically testing everything. It takes a lot of time to set up and costs the most.\n\n**Integration Testing** consists of testing the interaction between elements of your application, for example, communication between your UI and an API. It takes a shorter amount of time to set up, and isn't too expensive.\n\n**Unit Testing** is different as it consists of testing isolated parts of the code, as units. These units usually take the form of methods, properties, UI element actions etc. It is the fastest and cheapest to implement.\n\nYou've probably noted that the higher you go in our pyramid, the more time and money it takes to set up our tests. That's why a lot of projects tend to focus on unit tests as they can help you know if your code truly works by covering most scenarios, save time, and simplify deployment processes.\n\n<br>\n<br>\n\n## Example of a unit test ‚öôÔ∏è\n\nBefore we get into it, it's worth mentioning what a testing framework is.\n\nA testing framework allows you to easily set up your testing environment and run test suites. You could see testing frameworks as what React or Vue are to UI development, they give you a multitude of tools and make your life easier by doing so.  \nI would immensely recommend [Jest](https://jestjs.io/) as it is commonly seen on most projects and is maintained by a great team of engineers at Facebook. Note that I will be using this framework in my examples.\n\nI'll be covering a few basic examples of unit tests, so let's get to it. If you want to follow along, feel free to use a website called [TDDBin](http://tddbin.com/).\n\n```javascript\n// 1. The method we want to test\nfunction add(x, y) {\n  return x + y;\n}\n\n// 2. A test suite\ndescribe(\"add method\", () => {\n  // 3. A unit test\n  it(\"should return 2\", () => {\n    // 4. An assertion\n    expect(add(1, 1)).toBe(2);\n  });\n});\n```\n\nLet's break down the code:\n\n1. **The method we want to test**. As we noted earlier, unit testing often applies to methods or UI element interactions. A great way to know what to test is to go from the ground up looking at an application's components. \"What does my method take as an input and what is its output?\", \"Does my method impact my component's state?\", \"What are the edge cases?\" are all good questions to find a starting point.\n2. **A test suite**, that should be described briefly and groups unit tests that are related. For example, a test suite could include all tests that concern a specific method. You can declare as many test suites as you want, its primary role is to make your test logs more readable.\n3. **A unit test**, accompanied by a description, the statement(s) inside the callback is the test itself.\n4. **A test assertion**. Testing is all about assertions, comparing a given value to an expected one. Here, we give the return value of our `add` method with 1 and 1 as parameters and expect the result to be 2.\n\n<br>\n\n### Other tests we could add\n\nHere are some other tests that would be reasonable to add for this example:\n\nTesting negative results:\n\n```javascript\nit(\"should return -2\", () => {\n  expect(add(0, -2)).toBe(-2);\n});\n```\n\nTesting our method's error handling (when anything other than a number is passed as parameter):\n\n```javascript\nfunction add(x, y) {\n  // Check if the parameters are numbers\n  // If not, throw an error\n  if (isNaN(x) || isNaN(y)) {\n    throw new Error(\"Parameter is not a number !\");\n  }\n  return x + y;\n}\n\ndescribe(\"add method\", () => {\n  it(\"should throw an error if NaN is given as parameter\", () => {\n    expect(add).toThrow();\n  });\n});\n```\n\n> **Note**: you may have seen that we used `toThrow()` and not `toBe()`. Jest offers a [multitude](https://jestjs.io/docs/en/using-matchers) of matchers to check if a value matches a given result. So you can check if a value is `null`, `true`, greater or less than etc.\n\n<br>\n<br>\n\n## Concrete example of unit testing üß™\n\nAlright, I've shown a pretty unrealistic example of unit testing, so let's try it on a **real** component from start to finish.\n\nI've created a project using `create-react-app`, which comes out-of-the-box with Jest set up. Whatever framework you're using, most of their CLIs configure Jest for you, so it's just a matter of creating your test files and writing your tests ! If you're not using one of those CLIs or just need to configure Jest from scratch, feel free to read up on their [getting started](https://jestjs.io/docs/en/getting-started.html) documentation.\n\nNow, let's install [Enzyme](https://airbnb.io/enzyme/) which will allow us to test our components' output by rendering them. Note that there are many well known tools that can be used to test Front-End applications, Jest and Enzyme being some of the most well known.\n\nLet's follow their introduction documentation by installing the necessary packages:\n\n`npm i --save-dev enzyme enzyme-adapter-react-16 react-test-renderer`\n\nWe then need to set up our adapter by creating the following file:\n\n```javascript\n// /src/setupTests.js\nimport { configure } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\n\nconfigure({ adapter: new Adapter() });\n```\n\n> **Note**: if you're using an older version of React, make sure to configure the right adapter for the version you're using, feel free to read up on their [installation](https://airbnb.io/enzyme/docs/installation/#installation) documentation.\n\nYou may have noted that `create-react-app` creates the following unit test:\n\n```javascript\n// App.spec.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nit(\"renders without crashing\", () => {\n  const div = document.createElement(\"div\");\n  ReactDOM.render(<App />, div);\n  ReactDOM.unmountComponentAtNode(div);\n});\n```\n\nAll test files have a similar format: `*.spec.js` or `*.test.js` depending on your preference. I personally always use the first format. üòÑ\n\nTry it out by running `npm run test` in your console. You should get the following output:\n\n```bash\n PASS  src/App.spec.js\n  ‚úì renders without crashing (2ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.097s, estimated 1s\nRan all test suites.\n```\n\nAwesome, we've run our first unit test.\n\nWe'll now build a basic counter application that lets the user click on a button to increase a value on the screen. The source code can be found [here](https://github.com/christopherkade/unit-testing-demo) so feel free to clone or fork the repo to try it out.\n\nOur component looks like the following:\n\n```javascript\nclass App extends Component {\n  state = {\n    counter: 0,\n  };\n\n  handleClick = () => {\n    this.setState((state) => {\n      return {\n        counter: state.counter + 1,\n      };\n    });\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <h1>{this.state.counter}</h1>\n          <button className=\"button\" onClick={this.handleClick}>\n            Click Me !\n          </button>\n        </header>\n      </div>\n    );\n  }\n}\n```\n\nSo where do we start? Ask yourself what aspects of the component we could test, in this case:\n\n- What's displayed on the screen initially\n- That the counter increases when the user clicks on the button\n\n<br>\n\n### Testing rendered values\n\nEnzyme's JQuery-like syntax and Jest's assertions make it extremely easy to test these cases, here's how we should go about it:\n\n```javascript\nimport React from \"react\";\nimport App from \"./App\";\nimport { shallow } from \"enzyme\";\n\n// 1. Test suite\ndescribe(\"[UNIT] Testing the App component\", () => {\n  let wrapper;\n\n  // 2. A Jest setup helper function\n  beforeEach(() => {\n    // 3. Enzyme's shallow rendering\n    wrapper = shallow(<App />);\n  });\n\n  describe(\"Component validation\", () => {\n    // 4. Our unit test, checking if the initial value is 0\n    it(\"displays 0 as a default value\", () => {\n      expect(wrapper.find(\"h1\").text()).toContain(\"0\");\n    });\n  });\n});\n```\n\nYou probably noticed a couple of things, so let's go through the code.\n\n1. As we mentioned earlier, Jest allows us to create test suites to organize our tests.\n2. Sometimes you want to setup something before a test runs or wrap other things after they do. This is why Jest offers setup and teardown helper functions that you can read up on [here](https://jestjs.io/docs/en/setup-teardown). The main one's you'll find yourself using are `beforeEach` and `beforeAll` as they will allow you to render your components, which brings us to number 3.\n3. Shallow rendering is one of the few rendering methods Enzyme offers. In the case of shallow rendering, we render the component itself **without** its children. This allows you to test the component as a unit, so that if you modify a child it won't affect the current component being tested. See Enzyme's rendering as an instance of your component as it is when it first comes up on your screen, with its internal states, HTML and all.\n4. Our first test is simple: we look up the component's `h1` title by passing a selector to the `find` method and access its text directly; we then check, using Jest's assertion methods, that it contains the value 0. Simple, right?\n\nAlright, on to our second test.\n\n<br>\n\n### Testing events\n\nTesting events is made very simple thanks to Enzyme, here's how we test that a click to our button increases our counter:\n\n```javascript\nit(\"should increase counter when the button is clicked\", () => {\n  wrapper.find(\"button\").simulate(\"click\");\n  expect(wrapper.find(\"h1\").text()).toContain(\"1\");\n});\n```\n\nWe use the `simulate` method on the `button` wrapper to trigger the event and then check our title to see if it is equal to 1.\n\n> **Note**: most event types can be simulated using the simulate method including inputs, clicks, focus, blurs, scrolls etc.\n\n<br>\n\n### Testing code coverage\n\nAn important concept to grasp is code coverage, it represents the percentage of your code being tested.\n\nCode coverage tools check the following:\n\n- Statements: how many statements of your code are executed.\n- Branches: branches created by conditional statements (if/else) that may or may not be executed.\n- Functions: the number of functions that have been called.\n- Lines: the proportion of lines executed during the tests.\n\nAnd could look something like this (based on our previous example):\n\n![](https://user-images.githubusercontent.com/15229355/55360258-1d20ce80-54d4-11e9-9cbc-e08a0e437042.png)\n\nOne of the most used code coverage tools our there is called [Istanbul](https://istanbul.js.org/) and is used by create-react-app to report your application's code coverage when you run the following command `npm run test --coverage`.\n\nTools like Istanbul generate a code coverage report in the form of HTML files that can help you have an overview of what parts of your code haven't been tested. It highlights the specific lines not covered during your unit tests to help you reach that sweet 100% coverage.\n\n> **Note**: code coverage isn't everything and 100% coverage doesn't mean you've tested every scenario for a given component, so you should only strive to it when it makes sense.  \n> As noted by [@edaqa](https://twitter.com/edaqa), code coverage can be seen as a bad metric, as it may \"provide a false sense of security by equating lines executed with lines tested\" amongst other problems. So use it with caution as a way to have an overview over how much of your code is covered, and by not confusing a metric with an objective.\n\n<br>\n<br>\n\n## Honorable mentions üëè\n\nHere are some things that I didn't talk about that deserve to be mentioned, in no particular order:\n\n- Jest has a `--watch` option that allows to run your tests automatically when a test file is changed.\n- A great [cheatsheet](https://devhints.io/enzyme) for Enzyme.\n- Make sure to check out the files generated during code coverage reports, knowing exactly which lines haven't been covered can save tremendous amounts of time.\n- Make sure that you're testing something that needs to be tested, avoid testing that third-party packages do their job and focus on testing that your component fits your specifications.\n- The concept of Test Driven Development (TDD) can be described as follows: \"Test-driven development is the act of first deciding what you want your program to do (the specifications), formulating a failing test, then writing the code to make that test pass\" ([link](https://medium.freecodecamp.org/an-introduction-to-test-driven-development-c4de6dce5c)), don't worry if you don't understand it fully right away, but it's important to eventually understand its value and to know that you might be asked to one day practice it. Here's a great [starting point](https://github.com/dwyl/learn-tdd).\n\n<br>\n<br>\n\n## Closing thoughts üéÅ\n\nI believe this is enough information for a single introduction to Front-End testing and should get you on your way to learning many, many things about unit testing as a whole.\n\nTesting may feel like a time-consuming and useless practice to you right now, but believe me, you will eventually realize how relevant testing an application is. It will help you debug and structure your code, save time, reduce technical debt, improve your workflow and overall boost your productivity on the long run.\n\nAs always, thank you so much for taking the time to read this, I hope you've learned something along the way.\n\nIf you have any questions please feel free to send them to me on Twitter [@christo_kade](https://twitter.com/christo_kade), and if you enjoyed this post, following me will give you a heads up whenever I upload anything new !\n"},"__N_SSG":true}