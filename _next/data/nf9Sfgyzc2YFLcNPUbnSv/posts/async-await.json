{"pageProps":{"frontmatter":{"title":"The dangers of async/await ","date":"2020-01-16","description":"Pretty, but dangerous.","slug":"/posts/async-await","isPublished":true},"content":"\nAfter a few months consulting on the rewriting of a large-scale application, I've come to realize that `async`/`await` was used de facto for most asynchronous operation. For example, consider this Vue code snippet:\n\n```javascript\n async initStore(query) {\n    await this.getConfig();\n    await this.getUser();\n    await this.checkRussianContext(query);\n\n    await this.getBasket(this.$store.state.config.selectedCurrency),\n\n    await this.$store.dispatch('options/fetchOptions', {\n      basket : this.$store.state.basket,\n    });\n },\n```\n\nHere, each line of code is executed **when its predecessor is completed**. Meaning `getUser` will wait for `getConfig` to finish fetching data before being executed.  \nHere are a few points that come to mind when seeing this snippet:\n\n- What if one line does not need data from the previous one? Why block its execution and slow down our application?\n- Could we run unrelated methods in parallel using something like `Promise.all`?\n- Related methods should probably be using a `then` block to avoid blocking the rest of the method\n\nThe point this article will be to help you catch this [code smell](https://en.wikipedia.org/wiki/Code_smell) by showing you that using `async`/`await` by default in some cases can have a drastic impact on performance and UX.\n\n## Unrelated queries should be executed in parallel\n\nLet's see some concrete data, shall we?\n\nHere's the code snippet we'll be analyzing:\n\n```javascript\nconst getUserData = async () => {\n  // Get a random dog as our user's avatar\n  const res = await fetch(\"https://dog.ceo/api/breeds/image/random\");\n  const { message } = await res.json();\n\n  // Get our user's general data\n  const user = await fetch(\"https://randomuser.me/api/\");\n  const { results } = await user.json();\n\n  // ...\n};\n```\n\nRunning this snippet 100 times on fast 3G (using Chrome's dev tools), the average execution time is **1231.10ms**.\n\nBut why block the second query when it doesn't need the result of the first? Let's change our code to the following and re-run it 100 times.\n\n```javascript\nconst getUserDataFaster = async () => {\n  // Execute both requests in parallel\n  const [res, user] = await Promise.all([\n    fetch(\"https://dog.ceo/api/breeds/image/random\"),\n    fetch(\"https://randomuser.me/api/\"),\n  ]);\n  const [{ message }, { results }] = await Promise.all([\n    res.json(),\n    user.json(),\n  ]);\n\n  // ...\n};\n```\n\nWe now have an average execution time of **612.50ms**, half the time needed when both queries were executed one after the other.\n\nThe point is: if you can execute time-consuming queries in parallel, do it.\n\nTry it out yourself on this [codepen](https://codepen.io/christopherkade/pen/bGNjMeP?editors=1010).\n\n## Unrelated code should not have to wait\n\nLet's take my first example but with a twist:\n\n```javascript\n async initStore(query) {\n   await Promise.all([\n     await this.getConfig(),\n     await this.getUser(),\n     await this.checkRussianContext(query)\n   ])\n\n   await this.getBasket(this.$store.state.config.selectedCurrency),\n\n   await this.$store.dispatch('options/fetchOptions', {\n     basket : this.$store.state.basket,\n   });\n\n   await initBooking()\n },\n```\n\nHere, the first 3 requests are executed in parallel, whereas the next ones rely on data fetched beforehand and will therefore be executed afterwards. Although this snippet poses a problem, did you spot it?\n\nPoor little `initBooking` will have to wait for both `getBasket` and `fetchOptions` to finish before executing even though it has nothing to do with the data they'll fetch.  \nAn easy solution is to trade the `await` with a simple `then` block.\n\n```javascript\n  async initStore(query) {\n    await Promise.all([\n      await this.getConfig(),\n      await this.getUser(),\n      await this.checkRussianContext(query)\n    ])\n\n    this.getBasket(this.$store.state.config.selectedCurrency).then(async () => {\n      await this.$store.dispatch('options/fetchOptions', {\n        basket : this.$store.state.basket,\n      });\n    })\n\n   await initBooking()\n },\n```\n\nThis way, both `getBasket` and `initBooking` will be executed alongside one another.\n\nWant to see it for yourself? Check out this [codepen](https://codepen.io/christopherkade/pen/BayOZqV?editors=0010) illustrating my example.\n\nI'll stop the article there so I don't overload you with examples, but you should get the gist of it by now.\n\n`async`/`await` are wonderful additions to the Javascript language but I hope you'll now ask yourself twice before using them !\n\nThank you for reading, I'd love it if you gave me a follow on Twitter [@christo_kade](https://twitter.com/christo_kade), this way we'll get to share our mutual skepticism towards `awaits` ❤️\n"},"__N_SSG":true}