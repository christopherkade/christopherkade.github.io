<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Understanding the Node.js Event Loop</title><meta name="description" content="A surface level explanation to understand how it functions."/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/1e102b74ae7fb361.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1e102b74ae7fb361.css" data-n-g=""/><link rel="preload" href="/_next/static/css/73f774a748465508.css" as="style"/><link rel="stylesheet" href="/_next/static/css/73f774a748465508.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-83105742ca734edf.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-7f42b959b0669217.js" defer=""></script><script src="/_next/static/chunks/pages/_app-02d136397748a460.js" defer=""></script><script src="/_next/static/chunks/959-1f1497f0fca8f7ff.js" defer=""></script><script src="/_next/static/chunks/89-8a0243d41d3ea2a6.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-1847102f797143b3.js" defer=""></script><script src="/_next/static/vJ6mT7KSHyhos-uCUnqg5/_buildManifest.js" defer=""></script><script src="/_next/static/vJ6mT7KSHyhos-uCUnqg5/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="__className_555963"><nav class="fixed top-0 w-full text-grey-900 px-1 sm:px-4 bg-theme-primary z-10 shadow-none hidden md:block"><div class="container flex flex-wrap items-center justify-center mx-auto"><a class="absolute my-auto left-7 hidden sm:block tracking-wide strike-through-violet" href="/">CHRISTOPHER KADE</a><div class="block w-auto" id="navbar-default"><ul class="flex p-2 flex-row md:space-x-8 mt-0 text-sm font-medium"><li><a class="list__link strike-through-animation hover:strike-through-yellow block py-2 px-2 md:px-0 font-extralight" href="/">About,</a></li><li class="ml-0"><a class="list__link strike-through-animation hover:strike-through-yellow block py-2 px-2 md:px-0 font-extralight" href="/#articles">articles,</a></li><li class="ml-0"><a class="list__link strike-through-animation hover:strike-through-yellow block py-2 px-2 md:px-0 font-extralight" href="/#projects">projects,</a></li><li class="ml-0"><a class="list__link strike-through-animation hover:strike-through-yellow block py-2 px-2 md:px-0 font-extralight" href="/#contact">contact</a></li></ul></div></div></nav><div class="pt-8 md:pt-28 max-w-7xl p-6 mx-auto"><article class="md:max-w-[60%] mx-auto"><header class="mb-14"><a class="flex w-fit mb-8 text-lg group" href="/posts"><img alt="Back button to all articles" src="/_next/static/media/back-arrow.0ade2ae6.svg" width="15" height="15" decoding="async" data-nimg="1" class="mr-2" loading="lazy" style="color:transparent"/><span class="group-hover:strike-through-yellow">All articles</span></a><h1 class="text-4xl box-decoration-clone strike-through-green inline">Understanding the Node.js Event Loop</h1></header><main><div class="markdown-styles_reactMarkDown__k3MfX"><p>Next week, I will be presenting Node&#x27;s Event Loop system (we&#x27;ll call it the EL from now on) during a <a href="https://www.hrzone.com/hr-glossary/what-is-a-brown-bag-lunch">BBL</a> organized by <a href="https://www.zenika.com/">Zenika</a>. I chose this subject as I always wanted to delve deeper in my understanding of it and this was the perfect opportunity to do so.</p>
<p>This blog post is a textual representation of what I will say using the following <a href="https://slides.com/christopherkade/deck-1/fullscreen">slides</a>.</p>
<p>&lt;br&gt;<!-- -->&lt;br&gt;</p>
<h2>Why learn about the Event Loop?</h2>
<p>It&#x27;s always a good thing to understand how the tools we use work on a lower level. In the case of the EL specifically, it would allow me to understand the workflow of one of the runtimes I use the most which, in time, could help me debug my code more efficiently.</p>
<p>&lt;br&gt;<!-- -->&lt;br&gt;</p>
<h2>Summing up the Event Loop</h2>
<p>Let&#x27;s sum up the EL beyond what you&#x27;d find on Google images, as checking &quot;Node.js Event Loop&quot; often gives out a rather high-level representation of the process like so:</p>
<!-- -->&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;80%&quot; height=&quot;80%&quot; src=&quot;https://user-images.githubusercontent.com/15229355/51047335-80335100-15c8-11e9-88b4-51a4e4f91e06.png&quot;&gt;
&lt;/p&gt;<!-- -->
<p>The Event Loop could be represented as a postwoman/postman delivering a pile of letters, she/he would give out the first letter to its recipient, <strong>wait until it finishes reading it</strong> and would move on to the next person.</p>
<p>See how I pointed out part of that statement? That&#x27;s because the <strong>Event Loop executes only one task at a time</strong>. This is extremely important as we will see later on when it comes to performance and the way we design our applications.</p>
<p>Before moving on, it&#x27;s important to note that Node.js is composed of the following blocks:</p>
<!-- -->&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;60%&quot; height=&quot;60%&quot; src=&quot;https://user-images.githubusercontent.com/15229355/51047832-bcb37c80-15c9-11e9-8058-ce1b05f9f7c2.png&quot;&gt;
&lt;/p&gt;<!-- -->
<p>The <strong>Event Loop</strong>, a layer of <strong>C++</strong> (used for Chrome&#x27;s V8 engine) and a layer of <strong>Javascript</strong>.</p>
<p>When the EL received a message to execute, it passes through that layer of C++, to the JS, executes it and then goes back to the EL like so.</p>
<!-- -->&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;60%&quot; height=&quot;60%&quot; src=&quot;https://user-images.githubusercontent.com/15229355/51048338-00f34c80-15cb-11e9-9cfb-956d76246006.png&quot;&gt;
&lt;/p&gt;<!-- -->
<p>An important parts of this process are the following two queues: the <strong>nextTickQueue</strong> (NTQ) and the <strong>microTaskQueue</strong> (MTQ).</p>
<!-- -->&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;60%&quot; height=&quot;60%&quot; src=&quot;https://user-images.githubusercontent.com/15229355/51048451-4152ca80-15cb-11e9-9c24-e431ba9b9063.png&quot;&gt;
&lt;/p&gt;<!-- -->
<p>The NTQ contains callbacks used with <code>process.nextTick(callback)</code> and the MTQ contains all callbacks used with the resolution of a promise via <code>.then(callback)</code>, <code>.catch(callback)</code> and <code>.finally(callback)</code>. So when one of these is called, its callback is added to its respective queue to be executed later.</p>
<p>When do they get executed you may ask?<br/>
<!-- -->Whenever the back and forth we mentioned earlier is done, it checks the queues, executes any existing callback and then resumes its work.</p>
<p>This brings up our second very important point: <strong>when Javascript is running, the Event Loop is not</strong>. This is also known as the Event Loop delay.</p>
<p>Here&#x27;s some code to illustrate:</p>
<!-- -->&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;90%&quot; height=&quot;90%&quot; src=&quot;https://user-images.githubusercontent.com/15229355/51048951-bd014700-15cc-11e9-9799-b6ab13cf99be.png &quot;&gt;
&lt;/p&gt;<!-- -->
<p>As you can see, the rather large <code>for</code> loop blocks any other execution (that includes I/O, HTTP requests etc.) for its whole duration.</p>
<p>We&#x27;ve summarized the Event Loop pretty well, let&#x27;s talk about its architecture.</p>
<p>&lt;br&gt;<!-- -->&lt;br&gt;</p>
<h2>The Event Loop&#x27;s architecture</h2>
<p>When most developers think of the EL, they usually visualize a single stack or queue. This is actually a misconception (that even I had in the past) as it is composed of multiple queues (or queue-like structures) like so:</p>
<!-- -->&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;60%&quot; height=&quot;60%&quot; src=&quot;https://user-images.githubusercontent.com/15229355/51109357-4e530200-17f5-11e9-8976-fe754a7092eb.png&quot;&gt;
&lt;/p&gt;<!-- -->
<p>Each one of these queues have their own purpose that I&#x27;ll cover without going into too much detail. For more detail, visit <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#phases-in-detail">the official documentation</a>.</p>
<p>&lt;br&gt;<!-- -->&lt;br&gt;</p>
<h3>Timer</h3>
<p>The start of the loop, handles timer related callbacks from <a href="https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_args"><code>setTimeout</code></a> and <a href="https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args"><code>setInterval</code></a>.</p>
<h3>Pending I/O callbacks</h3>
<p>Handles the execution of some system callbacks, for example, a TCP error would be queued here.</p>
<h3>Idle, prepare</h3>
<p>Handles internal operations for Node.</p>
<h3>Poll</h3>
<p>This phase handles data related operations (such as a file read) and new connections (such as a new socket).</p>
<h3>Check</h3>
<p>Handles <a href="https://nodejs.org/api/timers.html#timers_setimmediate_callback_args"><code>setImmediate</code></a> callbacks.</p>
<h3>Close callbacks</h3>
<p>Handles callbacks related to closing, such as <code>socket.on(&#x27;close&#x27;, () =&gt; {})</code> when a socket or handle is closed abruptly.</p>
<!-- -->&lt;br&gt;<!-- -->
<p>There is so much more to these phases, I truly recommend to read up on them in the documentation linked earlier as each phase has a different way of handling callback execution.</p>
<p>&lt;br&gt;<!-- -->&lt;br&gt;</p>
<h2>Things to remember from this article</h2>
<p>We covered some very important points in this article, so here&#x27;s a TL;DR to remember:</p>
<ul>
<li>The Event Loop executes only <strong>one</strong> task at a time</li>
<li>When Javascript <strong>is running</strong>, the Event Loop <strong>is not</strong> (as they both run on a single thread)</li>
<li>The Event Loop is composed of <strong>more than one</strong> queue (or queue-like structure)</li>
</ul>
<p>Thank you so much for taking the time to read this article, I hope it has taught you on a lower level the workings of Node&#x27;s Event Loop system. Researching on it helped be grasp some concepts that will probably be of use in my future projects.</p>
<p><a href="https://twitter.com/christo_kade">@christo_kade</a></p></div></main></article></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"Understanding the Node.js Event Loop","description":"A surface level explanation to understand how it functions.","date":"2019-01-13","slug":"/posts/node-eventloop","isPublished":true},"content":"\nNext week, I will be presenting Node's Event Loop system (we'll call it the EL from now on) during a [BBL](https://www.hrzone.com/hr-glossary/what-is-a-brown-bag-lunch) organized by [Zenika](https://www.zenika.com/). I chose this subject as I always wanted to delve deeper in my understanding of it and this was the perfect opportunity to do so.\n\nThis blog post is a textual representation of what I will say using the following [slides](https://slides.com/christopherkade/deck-1/fullscreen).\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Why learn about the Event Loop?\n\nIt's always a good thing to understand how the tools we use work on a lower level. In the case of the EL specifically, it would allow me to understand the workflow of one of the runtimes I use the most which, in time, could help me debug my code more efficiently.\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Summing up the Event Loop\n\nLet's sum up the EL beyond what you'd find on Google images, as checking \"Node.js Event Loop\" often gives out a rather high-level representation of the process like so:\n\n\u003cp align=\"center\"\u003e\n  \u003cimg width=\"80%\" height=\"80%\" src=\"https://user-images.githubusercontent.com/15229355/51047335-80335100-15c8-11e9-88b4-51a4e4f91e06.png\"\u003e\n\u003c/p\u003e\n\nThe Event Loop could be represented as a postwoman/postman delivering a pile of letters, she/he would give out the first letter to its recipient, **wait until it finishes reading it** and would move on to the next person.\n\nSee how I pointed out part of that statement? That's because the **Event Loop executes only one task at a time**. This is extremely important as we will see later on when it comes to performance and the way we design our applications.\n\nBefore moving on, it's important to note that Node.js is composed of the following blocks:\n\n\u003cp align=\"center\"\u003e\n  \u003cimg width=\"60%\" height=\"60%\" src=\"https://user-images.githubusercontent.com/15229355/51047832-bcb37c80-15c9-11e9-8058-ce1b05f9f7c2.png\"\u003e\n\u003c/p\u003e\n\nThe **Event Loop**, a layer of **C++** (used for Chrome's V8 engine) and a layer of **Javascript**.\n\nWhen the EL received a message to execute, it passes through that layer of C++, to the JS, executes it and then goes back to the EL like so.\n\n\u003cp align=\"center\"\u003e\n  \u003cimg width=\"60%\" height=\"60%\" src=\"https://user-images.githubusercontent.com/15229355/51048338-00f34c80-15cb-11e9-9cfb-956d76246006.png\"\u003e\n\u003c/p\u003e\n\nAn important parts of this process are the following two queues: the **nextTickQueue** (NTQ) and the **microTaskQueue** (MTQ).\n\n\u003cp align=\"center\"\u003e\n  \u003cimg width=\"60%\" height=\"60%\" src=\"https://user-images.githubusercontent.com/15229355/51048451-4152ca80-15cb-11e9-9c24-e431ba9b9063.png\"\u003e\n\u003c/p\u003e\n\nThe NTQ contains callbacks used with `process.nextTick(callback)` and the MTQ contains all callbacks used with the resolution of a promise via `.then(callback)`, `.catch(callback)` and `.finally(callback)`. So when one of these is called, its callback is added to its respective queue to be executed later.\n\nWhen do they get executed you may ask?  \nWhenever the back and forth we mentioned earlier is done, it checks the queues, executes any existing callback and then resumes its work.\n\nThis brings up our second very important point: **when Javascript is running, the Event Loop is not**. This is also known as the Event Loop delay.\n\nHere's some code to illustrate:\n\n\u003cp align=\"center\"\u003e\n  \u003cimg width=\"90%\" height=\"90%\" src=\"https://user-images.githubusercontent.com/15229355/51048951-bd014700-15cc-11e9-9799-b6ab13cf99be.png \"\u003e\n\u003c/p\u003e\n\nAs you can see, the rather large `for` loop blocks any other execution (that includes I/O, HTTP requests etc.) for its whole duration.\n\nWe've summarized the Event Loop pretty well, let's talk about its architecture.\n\n\u003cbr\u003e\u003cbr\u003e\n\n## The Event Loop's architecture\n\nWhen most developers think of the EL, they usually visualize a single stack or queue. This is actually a misconception (that even I had in the past) as it is composed of multiple queues (or queue-like structures) like so:\n\n\u003cp align=\"center\"\u003e\n  \u003cimg width=\"60%\" height=\"60%\" src=\"https://user-images.githubusercontent.com/15229355/51109357-4e530200-17f5-11e9-8976-fe754a7092eb.png\"\u003e\n\u003c/p\u003e\n\nEach one of these queues have their own purpose that I'll cover without going into too much detail. For more detail, visit [the official documentation](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#phases-in-detail).\n\n\u003cbr\u003e\u003cbr\u003e\n\n### Timer\n\nThe start of the loop, handles timer related callbacks from [`setTimeout`](https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_args) and [`setInterval`](https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args).\n\n### Pending I/O callbacks\n\nHandles the execution of some system callbacks, for example, a TCP error would be queued here.\n\n### Idle, prepare\n\nHandles internal operations for Node.\n\n### Poll\n\nThis phase handles data related operations (such as a file read) and new connections (such as a new socket).\n\n### Check\n\nHandles [`setImmediate`](https://nodejs.org/api/timers.html#timers_setimmediate_callback_args) callbacks.\n\n### Close callbacks\n\nHandles callbacks related to closing, such as `socket.on('close', () =\u003e {})` when a socket or handle is closed abruptly.\n\n\u003cbr\u003e\n\nThere is so much more to these phases, I truly recommend to read up on them in the documentation linked earlier as each phase has a different way of handling callback execution.\n\n\u003cbr\u003e\u003cbr\u003e\n\n## Things to remember from this article\n\nWe covered some very important points in this article, so here's a TL;DR to remember:\n\n- The Event Loop executes only **one** task at a time\n- When Javascript **is running**, the Event Loop **is not** (as they both run on a single thread)\n- The Event Loop is composed of **more than one** queue (or queue-like structure)\n\nThank you so much for taking the time to read this article, I hope it has taught you on a lower level the workings of Node's Event Loop system. Researching on it helped be grasp some concepts that will probably be of use in my future projects.\n\n[@christo_kade](https://twitter.com/christo_kade)\n"},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"node-eventloop"},"buildId":"vJ6mT7KSHyhos-uCUnqg5","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>