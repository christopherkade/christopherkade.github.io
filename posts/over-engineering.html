<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>4 signs you‚Äôre over-engineering</title><meta name="description" content="Excessive test coverage, indirection, abstraction &amp; more"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/44b6be123bcd55f4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/44b6be123bcd55f4.css" data-n-g=""/><link rel="preload" href="/_next/static/css/3f7caf433ea30dd0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3f7caf433ea30dd0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-7f42b959b0669217.js" defer=""></script><script src="/_next/static/chunks/pages/_app-12b4dfb994acc62e.js" defer=""></script><script src="/_next/static/chunks/959-1f1497f0fca8f7ff.js" defer=""></script><script src="/_next/static/chunks/89-8a0243d41d3ea2a6.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-1847102f797143b3.js" defer=""></script><script src="/_next/static/7Njp6XFriYX9ByHpL65S3/_buildManifest.js" defer=""></script><script src="/_next/static/7Njp6XFriYX9ByHpL65S3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="__className_3aa315"><nav class="animate-textAppear fixed top-0 w-full text-grey-900 px-1 sm:px-4 bg-theme-primary z-10 shadow-none hidden md:block"><div class="container flex flex-wrap items-center justify-center mx-auto"><a class="absolute my-auto left-7 hidden sm:block tracking-wide strike-through-violet" href="/">CHRISTOPHER KADE</a><div class="block w-auto" id="navbar-default"><ul class="flex p-2 flex-row md:space-x-8 mt-0 text-sm font-medium"><li><a class="list__link strike-through-animation hover:strike-through-yellow block py-2 px-2 md:px-0 font-extralight" href="/">About,</a></li><li class="ml-0"><a class="list__link strike-through-animation hover:strike-through-yellow block py-2 px-2 md:px-0 font-extralight" href="/#articles">articles,</a></li><li class="ml-0"><a class="list__link strike-through-animation hover:strike-through-yellow block py-2 px-2 md:px-0 font-extralight" href="/#projects">projects,</a></li><li class="ml-0"><a class="list__link strike-through-animation hover:strike-through-yellow block py-2 px-2 md:px-0 font-extralight" href="/#contact">contact</a></li></ul></div></div></nav><div class="pt-8 md:pt-28 max-w-7xl p-6 mx-auto"><article class="md:max-w-[60%] mx-auto"><header class="mb-14"><a class="flex w-fit mb-8 text-lg group" href="/posts"><img alt="Back button to all articles" src="/_next/static/media/back-arrow.0ade2ae6.svg" width="15" height="15" decoding="async" data-nimg="1" class="mr-2" loading="lazy" style="color:transparent"/><span class="group-hover:strike-through-yellow">All articles</span></a><h1 class="text-4xl box-decoration-clone strike-through-violet inline">4 signs you‚Äôre over-engineering</h1></header><main><div class="markdown-styles_reactMarkDown__k3MfX"><p>During my first years as a Software Engineer I consulted for firms of different sizes (from 20+ to 5000+ people) and it exposed me to various levels of over-engineering. This can happen for a <strong>lot</strong> of reasons and is usually a collective issue that tends to get worse as time goes on.</p>
<p>This short list goes into some concrete(ish) examples of pitfalls and how to avoid them. Of course, this list in non-exhaustive and can be improved upon, so feel free to let me know if I‚Äôve missed any glaring signs of this issue !</p>
<h2>1. 100% test coverage is not always the answer</h2>
<p>The <a href="https://en.wikipedia.org/wiki/Pareto_principle">Pareto Principle</a> states that 80% of the consequences come from 20% of causes. In our case, the majority of our coverage will be done with a limited amount of tests, and the remaining percentage might take a lot of effort for little reward.</p>
<p>I recommend reading about the <a href="https://www.etestware.com/7-principles-of-testing/">ISTQB testing principles</a>, the second of which states that exhaustive testing is impossible.</p>
<blockquote>
<p>One of the most important skills a testing expert possesses is the ability to identify the most important functions to test.</p>
</blockquote>
<h2>2. Excessive indirection and abstraction of your code</h2>
<p>Have you ever been confronted with a bug in production, felt the rush of adrenaline while trying to fix it as quickly as possible and not being able to pin point where the exact source of the problem is? Did you have to go through layers upon layers of files, wondering why previous authors (yourself included) hid away details by placing them in some external function, four layers deep?</p>
<p>This is not as much of a problem when building a feature, as you‚Äôre focused on creating code that is clean and reusable, but it requires a lot more mental gymnastics when trying to understand it when you‚Äôre not the original author. Over abstraction can create unmaintainable &amp; untestable monoliths, that‚Äôs why I believe writing concrete code first and then abstracting is important.</p>
<p>If you ever review code and can‚Äôt understand the underlying business logic within, that should already raise a red flag.</p>
<blockquote>
<p>Always remember the Rule of Threes: an abstraction without at least three usages isn‚Äôt an abstraction. Good abstraction are extracted and not designed.</p>
</blockquote>
<h2>3. Premature use of micro-frontends and/or micro-services</h2>
<p>Micro-frontends (dividing parts of your application into smaller, self-contained units) can be beneficial in terms of DX &amp; performance, as it:</p>
<ul>
<li>Allows you to only build the relevant part of your application in your CI, making it faster</li>
<li>Allows you to ship parts of your app using different tech stacks</li>
<li>Allows to load only the relevant files to your client, making your application more performant</li>
<li>Allows teams to work independently in a &quot;standalone‚Äù version and iterate faster on features</li>
<li>And many more advantages I won‚Äôt get into ! I recommend <a href="https://semaphoreci.com/blog/microfrontends">this article</a> if you want to dive deeper.</li>
</ul>
<p>With all these benefits, why would it be a bad idea to use this architecture too quickly?</p>
<ul>
<li><strong>Can add complexity and little reward:</strong> Ask yourself: what are the concrete benefits to using them for our project specifically? Does your project have a lot of independent moving parts?</li>
<li><strong>Can add little to no benefits for a lot of work:</strong> Setting up an MFE takes a lot of configuration &amp; work side-by-side with your infrastructure team.</li>
<li><strong>Can increase the size of your payloads:</strong> if you have a diversity of technology stacks used, it may end up slowing down your user‚Äôs experience. This can manifest through duplication of common dependencies - let‚Äôs say two of your MFEs use React, you‚Äôd then have to download the dependency twice. A solution to that issue would be to use the same version of that dependency across your MFE, but that would introduce a form of build-time coupling of our MFEs which goes against a huge benefit mentioned above.</li>
<li><strong>Makes it harder to test your features:</strong> Here‚Äôs an example: say a banner on your homepage appears only when the user navigates to it from their profile, if both of these pages are individual MFEs, then you‚Äôd have a hard time reproducing that behavior locally as you‚Äôd probably be working on a standalone version of any given page.</li>
</ul>
<h2>4. Ignoring the YAGNI principle (You Aren‚Äôt Gonna Need It)</h2>
<p>The YAGNI principle (created as part of Extreme Programming by Ron Jeffries) states that a feature should only be developed when required and not when you foresee that you‚Äôll need it. The main point being that developers should not waste time on creating extraneous elements that may not be necessary and can hinder or slow the development process.</p>
<p>If you try to future proof your code all the time, you‚Äôll end up more often than not with unused code gathering dust in your repository.</p>
<p>Let‚Äôs say you need to declare a class <code>User</code> that has a method <code>getAllUsers</code>, you might start thinking that you‚Äôll eventually need <code>getUserById</code> and <code>getUserByEmail</code> and code them right away. But that‚Äôs when YAGNI comes in - you should probably reconsider it and only code it when a feature requires it, and for a couple of reasons:</p>
<ul>
<li>The requirements might change in the future and make you update already unused methods</li>
<li>The methods might simply never be used and take up space for no reason</li>
</ul>
<blockquote>
<p>Just like other programming principle (KISS, DRY etc.), YAGNI is pretty straight forward</p>
</blockquote>
<hr/>
<p>This list was inspired by <a href="https://twitter.com/housecor/status/1607412976876666880">this tweet</a> from Cory House, I recommend going through it as it&#x27;ll show you some other mistakes that can cause over-engineering.</p>
<p>Have you every been faced with obvious over-engineering in a previous project or jobs? I‚Äôd love to hear some of your stories !</p>
<p>Thanks for reading, I hope you got something out of this list üòÑ. And feel free to follow me on <a href="https://twitter.com/christo_kade">Twitter</a>, I&#x27;m always happy seeing my circle of dev friends grow ü•∞</p></div></main></article></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"4 signs you‚Äôre over-engineering","date":"2023-01-10","description":"Excessive test coverage, indirection, abstraction \u0026 more","slug":"/posts/over-engineering","isPublished":true},"content":"\nDuring my first years as a Software Engineer I consulted for firms of different sizes (from 20+ to 5000+ people) and it exposed me to various levels of over-engineering. This can happen for a **lot** of reasons and is usually a collective issue that tends to get worse as time goes on.\n\nThis short list goes into some concrete(ish) examples of pitfalls and how to avoid them. Of course, this list in non-exhaustive and can be improved upon, so feel free to let me know if I‚Äôve missed any glaring signs of this issue !\n\n## 1. 100% test coverage is not always the answer\n\nThe [Pareto Principle](https://en.wikipedia.org/wiki/Pareto_principle) states that 80% of the consequences come from 20% of causes. In our case, the majority of our coverage will be done with a limited amount of tests, and the remaining percentage might take a lot of effort for little reward.\n\nI recommend reading about the [ISTQB testing principles](https://www.etestware.com/7-principles-of-testing/), the second of which states that exhaustive testing is impossible.\n\n\u003e One of the most important skills a testing expert possesses is the ability to identify the most important functions to test.\n\n## 2. Excessive indirection and abstraction of your code\n\nHave you ever been confronted with a bug in production, felt the rush of adrenaline while trying to fix it as quickly as possible and not being able to pin point where the exact source of the problem is? Did you have to go through layers upon layers of files, wondering why previous authors (yourself included) hid away details by placing them in some external function, four layers deep?\n\nThis is not as much of a problem when building a feature, as you‚Äôre focused on creating code that is clean and reusable, but it requires a lot more mental gymnastics when trying to understand it when you‚Äôre not the original author. Over abstraction can create unmaintainable \u0026 untestable monoliths, that‚Äôs why I believe writing concrete code first and then abstracting is important.\n\nIf you ever review code and can‚Äôt understand the underlying business logic within, that should already raise a red flag.\n\n\u003e Always remember the Rule of Threes: an abstraction without at least three usages isn‚Äôt an abstraction. Good abstraction are extracted and not designed.\n\n## 3. Premature use of micro-frontends and/or micro-services\n\nMicro-frontends (dividing parts of your application into smaller, self-contained units) can be beneficial in terms of DX \u0026 performance, as it:\n\n- Allows you to only build the relevant part of your application in your CI, making it faster\n- Allows you to ship parts of your app using different tech stacks\n- Allows to load only the relevant files to your client, making your application more performant\n- Allows teams to work independently in a \"standalone‚Äù version and iterate faster on features\n- And many more advantages I won‚Äôt get into ! I recommend [this article](https://semaphoreci.com/blog/microfrontends) if you want to dive deeper.\n\nWith all these benefits, why would it be a bad idea to use this architecture too quickly?\n\n- **Can add complexity and little reward:** Ask yourself: what are the concrete benefits to using them for our project specifically? Does your project have a lot of independent moving parts?\n- **Can add little to no benefits for a lot of work:** Setting up an MFE takes a lot of configuration \u0026 work side-by-side with your infrastructure team.\n- **Can increase the size of your payloads:** if you have a diversity of technology stacks used, it may end up slowing down your user‚Äôs experience. This can manifest through duplication of common dependencies - let‚Äôs say two of your MFEs use React, you‚Äôd then have to download the dependency twice. A solution to that issue would be to use the same version of that dependency across your MFE, but that would introduce a form of build-time coupling of our MFEs which goes against a huge benefit mentioned above.\n- **Makes it harder to test your features:** Here‚Äôs an example: say a banner on your homepage appears only when the user navigates to it from their profile, if both of these pages are individual MFEs, then you‚Äôd have a hard time reproducing that behavior locally as you‚Äôd probably be working on a standalone version of any given page.\n\n## 4. Ignoring the YAGNI principle (You Aren‚Äôt Gonna Need It)\n\nThe YAGNI principle (created as part of Extreme Programming by Ron Jeffries) states that a feature should only be developed when required and not when you foresee that you‚Äôll need it. The main point being that developers should not waste time on creating extraneous elements that may not be necessary and can hinder or slow the development process.\n\nIf you try to future proof your code all the time, you‚Äôll end up more often than not with unused code gathering dust in your repository.\n\nLet‚Äôs say you need to declare a class `User` that has a method `getAllUsers`, you might start thinking that you‚Äôll eventually need `getUserById` and `getUserByEmail` and code them right away. But that‚Äôs when YAGNI comes in - you should probably reconsider it and only code it when a feature requires it, and for a couple of reasons:\n\n- The requirements might change in the future and make you update already unused methods\n- The methods might simply never be used and take up space for no reason\n\n\u003e Just like other programming principle (KISS, DRY etc.), YAGNI is pretty straight forward\n\n---\n\nThis list was inspired by [this tweet](https://twitter.com/housecor/status/1607412976876666880) from Cory House, I recommend going through it as it'll show you some other mistakes that can cause over-engineering.\n\nHave you every been faced with obvious over-engineering in a previous project or jobs? I‚Äôd love to hear some of your stories !\n\nThanks for reading, I hope you got something out of this list üòÑ. And feel free to follow me on [Twitter](https://twitter.com/christo_kade), I'm always happy seeing my circle of dev friends grow ü•∞\n"},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"over-engineering"},"buildId":"7Njp6XFriYX9ByHpL65S3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>