{"data":{"markdownRemark":{"id":"df0fe0bb-3d56-54a4-aaad-cc7977c4d612","html":"<p>Next week, I will be presenting Node’s Event Loop system (we’ll call it the EL from now on) during a <a href=\"https://www.hrzone.com/hr-glossary/what-is-a-brown-bag-lunch\">BBL</a> organized by <a href=\"https://www.zenika.com/\">Zenika</a>. I chose this subject as I always wanted to delve deeper in my understanding of it and this was the perfect opportunity to do so.</p>\n<p>This blog post is a textual representation of what I will say using the following <a href=\"https://slides.com/christopherkade/deck-1/fullscreen\">slides</a>.</p>\n<p><br><br></p>\n<h2 id=\"why-learn-about-the-event-loop\"><a href=\"#why-learn-about-the-event-loop\" aria-label=\"why learn about the event loop permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why learn about the Event Loop?</h2>\n<p>It’s always a good thing to understand how the tools we use work on a lower level. In the case of the EL specifically, it would allow me to understand the workflow of one of the runtimes I use the most which, in time, could help me debug my code more efficiently.</p>\n<p><br><br></p>\n<h2 id=\"summing-up-the-event-loop\"><a href=\"#summing-up-the-event-loop\" aria-label=\"summing up the event loop permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summing up the Event Loop</h2>\n<p>Let’s sum up the EL beyond what you’d find on Google images, as checking “Node.js Event Loop” often gives out a rather high-level representation of the process like so:</p>\n<p align=\"center\">\n  <img width=\"80%\" height=\"80%\" src=\"https://user-images.githubusercontent.com/15229355/51047335-80335100-15c8-11e9-88b4-51a4e4f91e06.png\">\n</p>\n<p>The Event Loop could be represented as a postwoman/postman delivering a pile of letters, she/he would give out the first letter to its recipient, <strong>wait until it finishes reading it</strong> and would move on to the next person.</p>\n<p>See how I pointed out part of that statement? That’s because the <strong>Event Loop executes only one task at a time</strong>. This is extremely important as we will see later on when it comes to performance and the way we design our applications.</p>\n<p>Before moving on, it’s important to note that Node.js is composed of the following blocks:</p>\n<p align=\"center\">\n  <img width=\"60%\" height=\"60%\" src=\"https://user-images.githubusercontent.com/15229355/51047832-bcb37c80-15c9-11e9-8058-ce1b05f9f7c2.png\">\n</p>\n<p>The <strong>Event Loop</strong>, a layer of <strong>C++</strong> (used for Chrome’s V8 engine) and a layer of <strong>Javascript</strong>.</p>\n<p>When the EL received a message to execute, it passes through that layer of C++, to the JS, executes it and then goes back to the EL like so.</p>\n<p align=\"center\">\n  <img width=\"60%\" height=\"60%\" src=\"https://user-images.githubusercontent.com/15229355/51048338-00f34c80-15cb-11e9-9cfb-956d76246006.png\">\n</p>\n<p>An important parts of this process are the following two queues: the <strong>nextTickQueue</strong> (NTQ) and the <strong>microTaskQueue</strong> (MTQ).</p>\n<p align=\"center\">\n  <img width=\"60%\" height=\"60%\" src=\"https://user-images.githubusercontent.com/15229355/51048451-4152ca80-15cb-11e9-9c24-e431ba9b9063.png\">\n</p>\n<p>The NTQ contains callbacks used with <code class=\"language-text\">process.nextTick(callback)</code> and the MTQ contains all callbacks used with the resolution of a promise via <code class=\"language-text\">.then(callback)</code>, <code class=\"language-text\">.catch(callback)</code> and <code class=\"language-text\">.finally(callback)</code>. So when one of these is called, its callback is added to its respective queue to be executed later.</p>\n<p>When do they get executed you may ask?<br>\nWhenever the back and forth we mentioned earlier is done, it checks the queues, executes any existing callback and then resumes its work.</p>\n<p>This brings up our second very important point: <strong>when Javascript is running, the Event Loop is not</strong>. This is also known as the Event Loop delay.</p>\n<p>Here’s some code to illustrate:</p>\n<p align=\"center\">\n  <img width=\"90%\" height=\"90%\" src=\"https://user-images.githubusercontent.com/15229355/51048951-bd014700-15cc-11e9-9799-b6ab13cf99be.png \">\n</p>\n<p>As you can see, the rather large <code class=\"language-text\">for</code> loop blocks any other execution (that includes I/O, HTTP requests etc.) for its whole duration.</p>\n<p>We’ve summarized the Event Loop pretty well, let’s talk about its architecture.</p>\n<p><br><br></p>\n<h2 id=\"the-event-loops-architecture\"><a href=\"#the-event-loops-architecture\" aria-label=\"the event loops architecture permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Event Loop’s architecture</h2>\n<p>When most developers think of the EL, they usually visualize a single stack or queue. This is actually a misconception (that even I had in the past) as it is composed of multiple queues (or queue-like structures) like so:</p>\n<p align=\"center\">\n  <img width=\"60%\" height=\"60%\" src=\"https://user-images.githubusercontent.com/15229355/51109357-4e530200-17f5-11e9-8976-fe754a7092eb.png\">\n</p>\n<p>Each one of these queues have their own purpose that I’ll cover without going into too much detail. For more detail, visit <a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#phases-in-detail\">the official documentation</a>.</p>\n<p><br><br></p>\n<h3 id=\"timer\"><a href=\"#timer\" aria-label=\"timer permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Timer</h3>\n<p>The start of the loop, handles timer related callbacks from <a href=\"https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_args\"><code class=\"language-text\">setTimeout</code></a> and <a href=\"https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\"><code class=\"language-text\">setInterval</code></a>.</p>\n<h3 id=\"pending-io-callbacks\"><a href=\"#pending-io-callbacks\" aria-label=\"pending io callbacks permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pending I/O callbacks</h3>\n<p>Handles the execution of some system callbacks, for example, a TCP error would be queued here.</p>\n<h3 id=\"idle-prepare\"><a href=\"#idle-prepare\" aria-label=\"idle prepare permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Idle, prepare</h3>\n<p>Handles internal operations for Node.</p>\n<h3 id=\"poll\"><a href=\"#poll\" aria-label=\"poll permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Poll</h3>\n<p>This phase handles data related operations (such as a file read) and new connections (such as a new socket).</p>\n<h3 id=\"check\"><a href=\"#check\" aria-label=\"check permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Check</h3>\n<p>Handles <a href=\"https://nodejs.org/api/timers.html#timers_setimmediate_callback_args\"><code class=\"language-text\">setImmediate</code></a> callbacks.</p>\n<h3 id=\"close-callbacks\"><a href=\"#close-callbacks\" aria-label=\"close callbacks permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Close callbacks</h3>\n<p>Handles callbacks related to closing, such as <code class=\"language-text\">socket.on(&#39;close&#39;, () =&gt; {})</code> when a socket or handle is closed abruptly.</p>\n<br>\n<p>There is so much more to these phases, I truly recommend to read up on them in the documentation linked earlier as each phase has a different way of handling callback execution.</p>\n<p><br><br></p>\n<h2 id=\"things-to-remember-from-this-article\"><a href=\"#things-to-remember-from-this-article\" aria-label=\"things to remember from this article permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Things to remember from this article</h2>\n<p>We covered some very important points in this article, so here’s a TL;DR to remember:</p>\n<ul>\n<li>The Event Loop executes only <strong>one</strong> task at a time</li>\n<li>When Javascript <strong>is running</strong>, the Event Loop <strong>is not</strong> (as they both run on a single thread)</li>\n<li>The Event Loop is composed of <strong>more than one</strong> queue (or queue-like structure)</li>\n</ul>\n<p>Thank you so much for taking the time to read this article, I hope it has taught you on a lower level the workings of Node’s Event Loop system. Researching on it helped be grasp some concepts that will probably be of use in my future projects.</p>\n<p><a href=\"https://twitter.com/christo_kade\">@christo_kade</a></p>","fields":{"slug":"/posts/node-eventloop","tagSlugs":["/tag/node/","/tag/javascript/"]},"frontmatter":{"date":"2019-01-13","description":"A surface level explanation to understand how it functions.","tags":["Node","Javascript"],"title":"Understanding the Node.js Event Loop"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/node-eventloop"}}